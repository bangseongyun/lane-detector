import cv2
import numpy as np
import math
from gpiozero import Servo
from gpiozero import Motor

# ==========================================
# 1. í•˜ë“œì›¨ì–´ ì„¤ì •
# ==========================================
servo = Servo(12)
motor = Motor(forward=13, backward=19)

# ==========================================
# 2. ì¹´ë©”ë¼ ë° ë³€ìˆ˜ ì„¤ì •
# ==========================================
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

last_steering = 0.0  # ì°¨ì„ ì„ ë†“ì³¤ì„ ë•Œ ì§ì „ ê°’ì„ ê¸°ì–µí•˜ê¸° ìœ„í•œ ë³€ìˆ˜
MAX_STEERING = 0.45  # ìµœëŒ€ ì¡°í–¥ê° ìœ ì§€

# [ì¤‘ìš” ìˆ˜ì •] ì§ì„  ì ë¦¼ ë³´ì • ì¶”ê°€ í•˜í–¥ (0.35 -> 0.25): ìš°ì¸¡ ì ë¦¼ì„ í™•ì‹¤íˆ í•´ì†Œí•˜ê³  ì¤‘ì•™ ì£¼í–‰ ìœ ë„
# ë§Œì•½ 0.20~0.25 ì‚¬ì´ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ì ë¦°ë‹¤ë©´ ì¥ì¹˜ ìì²´ì˜ ê¸°ê³„ì  ì ë¦¼ì´ í½ë‹ˆë‹¤.
STEERING_OFFSET = 0.25

# ì°¨ì„  ì†ì‹¤ ëŒ€ë¹„ë¥¼ ìœ„í•œ ì§ì „ í”„ë ˆì„ ë¼ì¸ ì •ë³´ ì €ì¥
last_r_m, last_r_b = [], []
last_l_m, last_l_b = [], []

print("System Ready. Start Driving...")
motor.forward(0.7)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Camera Error")
        motor.stop()
        break
    
    # ------------------------------------------------
    # 3. ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ë° Hough ë³€í™˜ 
    # ------------------------------------------------
    frame = cv2.resize(frame, (640, 480))
    height, width = frame.shape[:2]
    CENTER_X = width // 2  # 320
    
    # ROI ì„¤ì • (í•˜ë‹¨ ì ˆë°˜)
    # [ìˆ˜ì •] ROI ë†’ì´ë¥¼ ì¡°ê¸ˆ ë” ë„“ê²Œ ì„¤ì • (ì°¨ì„  ì¸ì‹ ë²”ìœ„ í™•ëŒ€)
    roi_y_start = int(height * 0.45) # 480 * 0.45 = 216. ì´ì „ì— ë¹„í•´ 3/4 ì •ë„ê¹Œì§€ ë´„
    roi_y_end = height 
    roi = frame[roi_y_start:roi_y_end, 0:width]
    line_draw = np.copy(roi)
    
    # y_line_roi (í˜„ì¬ í”„ë ˆì„ ê¸°ì¤€) : ì¡°í–¥ ëª©í‘œë¡œ ì‚¼ëŠ” ê°€ìƒì˜ ì„  (ì°¨ëŸ‰ ì „ë©´ì—ì„œ ì¡°ê¸ˆ ì•)
    y_line_roi = (height - 100) - roi_y_start # 480 - 100 = 380 (í”„ë ˆì„ ì „ì²´ ê¸°ì¤€). roi_y_startë¥¼ ëº€ ìœ„ì¹˜
    y_end_roi = height - roi_y_start

    # BGR -> Gray -> Blur -> Canny ìˆœì„œ
    roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(roi_gray, (5, 5), 0)
    # [ì¶”ê°€] Canny ì„ê³„ê°’ ì¡°ì •: ë¼ì¸ ì¸ì‹ì´ ë¶ˆì•ˆì •í•  ë•Œ ì—£ì§€ ê²€ì¶œì„ ì¡°ê¸ˆ ë” ë¯¼ê°í•˜ê²Œ ë˜ëŠ” ëœ ë¯¼ê°í•˜ê²Œ ì¡°ì • ê°€ëŠ¥
    edges = cv2.Canny(blur, 50, 150) # 50, 150ì€ í‘œì¤€ì ì´ë¯€ë¡œ ì¼ë‹¨ ìœ ì§€

    # HoughLinesP threshold=8 ìœ ì§€ (ê³¡ì„  ì¸ì‹ë¥  í–¥ìƒ)
    lines = cv2.HoughLinesP(edges, 
                            rho=1, 
                            theta=np.pi/180, 
                            threshold=8, 
                            minLineLength=10, 
                            maxLineGap=15)
    
    # ------------------------------------------------
    # 4. ì°¨ì„  êµ¬ë¶„ ë° ì¢Œí‘œ ê³„ì‚° 
    # ------------------------------------------------
    l_m, r_m = [], []
    l_b, r_b = [], []
    
    # ì¤‘ì•™ ì˜ì—­ ì œì™¸ë¥¼ ìœ„í•œ ì—¬ìœ  ê³µê°„ ìœ ì§€
    RIGHT_LANE_X_MIN = CENTER_X + 20  # 340
    LEFT_LANE_X_MAX = CENTER_X - 20   # 300
    
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0] 
            if (x2 - x1) == 0: continue
            m = (y2 - y1) / (x2 - x1) 
            y_b = y1 - m * x1 
            
            mid_x = (x1 + x2) / 2
            
            # ì˜¤ë¥¸ìª½ ì°¨ì„ : ê¸°ìš¸ê¸° ì–‘ìˆ˜, X ì¢Œí‘œ 340 ì´ìƒ
            if m > 0.1 and mid_x > RIGHT_LANE_X_MIN:
                r_m.append(m); r_b.append(y_b)
            # ì™¼ìª½ ì°¨ì„ : ê¸°ìš¸ê¸° ìŒìˆ˜, X ì¢Œí‘œ 300 ì´í•˜
            elif m < -0.1 and mid_x < LEFT_LANE_X_MAX:
                l_m.append(m); l_b.append(y_b)

    # ì´ˆê¸°í™”
    rx, lx = 0.0, 0.0
    r_cross, l_cross = 0, 0
    
    
    # ==================================================
    # 4-1. ì˜¤ë¥¸ìª½ ë¼ì¸ ì²˜ë¦¬ (ê°ì§€ ë° í™€ë“œ)
    # ==================================================
    if len(r_m) > 0:
        avg_m = np.mean(r_m)
        avg_y_b = np.mean(r_b)
        last_r_m, last_r_b = r_m.copy(), r_b.copy()

        if avg_m != 0: 
            r_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = r_cross - 320 
            rx = float(er/400) 

            # ì‹œê°í™” (ë¹¨ê°„ìƒ‰)
            x_start = int((0 - avg_y_b) / avg_m)
            x_end = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (255, 0, 0), 5)
    else:
        # ê°ì§€ ì‹¤íŒ¨: ì§ì „ ê°’ ì¬í™œìš© (í™€ë“œ)
        if len(last_r_m) > 0:
            avg_m = np.mean(last_r_m)
            avg_y_b = np.mean(last_r_b)
            if avg_m != 0:
                r_cross = int((y_line_roi - avg_y_b) / avg_m)
                er = r_cross - 320
                rx = float(er/400) 
                # ì‹œê°í™” (í™€ë“œ: ë§ˆì  íƒ€)
                x_start = int((0 - avg_y_b) / avg_m)
                x_end = int((y_end_roi - avg_y_b) / avg_m)
                cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (255, 0, 255), 5)


    # ==================================================
    # 4-2. ì™¼ìª½ ë¼ì¸ ì²˜ë¦¬ (ê°ì§€ ë° í™€ë“œ)
    # ==================================================
    if len(l_m) > 0: 
        avg_m = np.mean(l_m)
        avg_y_b = np.mean(l_b)
        last_l_m, last_l_b = l_m.copy(), l_b.copy()
    
        if avg_m != 0:
            l_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = l_cross - 320
            lx = float(er/400) 

            # ì‹œê°í™” (ì´ˆë¡ìƒ‰)
            x_start = int((0 - avg_y_b) / avg_m)
            x_end = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (0, 255, 0), 5)
    else:
        # ê°ì§€ ì‹¤íŒ¨: ì§ì „ ê°’ ì¬í™œìš© (í™€ë“œ)
        if len(last_l_m) > 0:
            avg_m = np.mean(last_l_m)
            avg_y_b = np.mean(last_l_b)
            if avg_m != 0:
                l_cross = int((y_line_roi - avg_y_b) / avg_m)
                er = l_cross - 320
                lx = float(er/400)
                # ì‹œê°í™” (í™€ë“œ: ë…¸ë€ìƒ‰)
                x_start = int((0 - avg_y_b) / avg_m)
                x_end = int((y_end_roi - avg_y_b) / avg_m)
                cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (0, 255, 255), 5)

    
    # ------------------------------------------------
    # 5. ìµœì¢… ì¡°í–¥ ê²°ì • ë¡œì§ (ğŸŒŸ ì¤‘ì•™ ì£¼í–‰ ì•ˆì •í™” ë° ì°¨ì„  ì†ì‹¤ ëŒ€ë¹„ ë¡œì§ ê°•í™”)
    # ------------------------------------------------
    final_steering = 0.0
    lines_detected_both = (r_cross != 0 and l_cross != 0)
    lines_detected_any = (r_cross != 0 or l_cross != 0)
    
    if lines_detected_both:
        # 1. ì–‘ìª½ ì°¨ì„  ê°ì§€ ì‹œ: ì¤‘ì•™ê°’ ì‚¬ìš© (ê°€ì¥ ì•ˆì •ì )
        final_steering = -(rx + lx) / 2
        
    elif l_cross != 0:
        # 2. ì™¼ìª½ ì°¨ì„ ë§Œ ê°ì§€ ì‹œ: Gain 1.0 ìœ ì§€
        final_steering = -lx * 1.0 
        
    elif r_cross != 0:
        # 3. ì˜¤ë¥¸ìª½ ì°¨ì„ ë§Œ ê°ì§€ ì‹œ: Gain 1.3 ìœ ì§€
        final_steering = -rx * 1.3
        
    else:
        # 4. [ì¤‘ìš” ìˆ˜ì •] ì°¨ì„  ë¯¸ê°ì§€ ì‹œ: ë§ˆì§€ë§‰ ìœ íš¨ ì¡°í–¥ê°’ì„ ì‚¬ìš© (ê´€ì„± ì£¼í–‰)
        # 0.0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ë©´ ê¸‰ê²©íˆ ì¤‘ì•™ìœ¼ë¡œ ëŒì•„ì™€ ë¶ˆì•ˆì •í•´ì§.
        final_steering = last_steering
        
    # [ìµœì¢… ìˆ˜ì •] ì§ì„  ì ë¦¼ ë³´ì • (í•­ìƒ ì ìš©): ìš°ì¸¡ ì ë¦¼ ì™„í™”
    # ì°¨ì„  ë¯¸ê°ì§€ ì‹œì—ë„ ì˜¤í”„ì…‹ì„ ë”í•˜ì—¬ ì§ì§„ ê´€ì„±ì´ ìœ ì§€ë˜ë„ë¡ í•¨
    final_steering += STEERING_OFFSET
        
    # ------------------------------------------------
    # 6. ëª¨í„° ì œì–´ ì‹¤í–‰ 
    # ------------------------------------------------
    
    # MAX_STEERING 0.45 ì ìš©
    if abs(final_steering) > MAX_STEERING:
        steering = math.copysign(MAX_STEERING, final_steering)
    else:
        steering = final_steering

    if -1.0 <= steering <= 1.0:
        servo.value = steering
        motor.forward(0.7)
        
        # [ìˆ˜ì •] last_steeringì€ ì°¨ì„ ì´ ê°ì§€ë˜ì—ˆì„ ë•Œë§Œ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜,
        # ì¡°í–¥ê°’ì´ ì˜¤í”„ì…‹ ê·¼ì²˜ì¼ ë•Œë§Œ ì—…ë°ì´íŠ¸í•˜ì—¬ ë¶ˆí•„ìš”í•œ ê°’ ì €ì¥ì„ ë§‰ìŒ.
        # ì—¬ê¸°ì„œëŠ” ê°ì§€ ì‹œ ì—…ë°ì´íŠ¸ ë¡œì§ì„ ìœ ì§€í•˜ë©´ì„œ, ì§ì„  ì£¼í–‰ ì‹œ ì´ˆê¸°í™” ë¡œì§ì„ ê°•í™”í•©ë‹ˆë‹¤.
        
        # ì°¨ì„ ì´ ê°ì§€ë˜ì—ˆì„ ë•Œë§Œ last_steering ì—…ë°ì´íŠ¸
        if lines_detected_any:
            last_steering = steering
            
        # ì§ì„  ì£¼í–‰(ì˜¤í”„ì…‹ ê·¼ì²˜) ì‹œ last_steeringì„ ì˜¤í”„ì…‹ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ì•ˆì •í™”
        if abs(steering - STEERING_OFFSET) < 0.05:
            last_steering = STEERING_OFFSET

    else:
        motor.stop()
        print("Steering Value Out of Range. Motor Stop.")

    # ------------------------------------------------
    # 7. í™”ë©´ ì¶œë ¥
    # ------------------------------------------------
    # [ìˆ˜ì •] ëª©í‘œì (y_line_roi)ì— ì¤‘ì•™ì„ ê³¼ì˜ êµì°¨ì ì„ ì‹œê°í™”
    if lines_detected_both:
        target_x = int((r_cross + l_cross) / 2)
        color = (0, 255, 255) # ë…¸ë€ìƒ‰
    elif l_cross != 0:
        target_x = l_cross + 175 # ì™¼ìª½ ë¼ì¸ì—ì„œ ì°¨ì„  í­ ì ˆë°˜ (139cm/2 + 25cm/2) ë§Œí¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ (ì„ì˜ì˜ í”½ì…€ê°’ 175 ì‚¬ìš©)
        color = (0, 165, 255) # ì£¼í™©ìƒ‰
    elif r_cross != 0:
        target_x = r_cross - 175 # ì˜¤ë¥¸ìª½ ë¼ì¸ì—ì„œ ì°¨ì„  í­ ì ˆë°˜ ë§Œí¼ ì™¼ìª½ìœ¼ë¡œ ì´ë™ (ì„ì˜ì˜ í”½ì…€ê°’ 175 ì‚¬ìš©)
        color = (0, 165, 255) # ì£¼í™©ìƒ‰
    else:
        target_x = 320 # ì°¨ì„  ì—†ì„ ë•Œ ì¤‘ì•™ (í°ìƒ‰ ì )
        color = (255, 255, 255)

    cv2.circle(line_draw, (target_x, y_line_roi), 5, color, -1)
    
    cv2.line(line_draw, (320, 0), (320, y_end_roi), (255, 255, 255), 1) 
    cv2.line(line_draw, (0, y_line_roi), (width, y_line_roi), (0, 0, 255), 1) 
    
    cv2.imshow("Lane View", line_draw)
    
    # ë””ë²„ê·¸: ì—£ì§€ ì´ë¯¸ì§€ í™•ì¸ (ì„ ì´ ì˜ ë³´ì´ëŠ”ì§€ í™•ì¸)
    cv2.imshow("Canny Edges", edges)

    if cv2.waitKey(1) == ord('q'):
        break

# ë£¨í”„ ì¢…ë£Œ í›„ ë¦¬ì†ŒìŠ¤ í•´ì œ
motor.stop()
cap.release() 
cv2.destroyAllWindows()
