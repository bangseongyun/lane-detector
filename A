import cv2
import numpy as np
import math
from gpiozero import Servo
from gpiozero import Motor

# ==========================================
# 1. 하드웨어 설정
# ==========================================
# 서보: GPIO 12
# 모터: GPIO 13(전진), 19(후진)
servo = Servo(12)
motor = Motor(forward=13, backward=19)

# ==========================================
# 2. 카메라 및 변수 설정
# ==========================================
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

last_steering = 0.0  # 차선을 놓쳤을 때 직전 값을 기억하기 위한 변수
MAX_STEERING = 0.4   # 서보모터 보호를 위한 최대 조향각 제한

print("System Ready. Start Driving...")
motor.forward(0.7)  # 기본 속도 0.8로 출발

# [수정됨] try 구문 제거 -> while문 바로 시작
while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Camera Error")
        break
    
    # ------------------------------------------------
    # 3. 이미지 전처리
    # ------------------------------------------------
    frame = cv2.resize(frame, (640, 480))
    height, width = frame.shape[:2]
    
    # ROI 설정
    roi_y_start = height // 2  
    roi_y_end = height 
    
    roi = frame[roi_y_start:roi_y_end, 0:width]
    line_draw = np.copy(roi)
    
    # 기준선(타겟 라인) 좌표 계산
    y_line_roi = (height - 120) - roi_y_start
    y_end_roi = height - roi_y_start

    # Canny & Hough 변환
    roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(roi_gray, (11, 11), 0)
    edges = cv2.Canny(blur, 50, 150)

    lines = cv2.HoughLinesP(edges, 
                            rho=1, 
                            theta=np.pi/180, 
                            threshold=10, 
                            minLineLength=10, 
                            maxLineGap=15)
    
    # ------------------------------------------------
    # 4. 차선 구분 및 좌표 계산
    # ------------------------------------------------
    l_m, r_m = [], []
    l_b, r_b = [], []
    
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0] 
            if (x2 - x1) == 0: continue
            m = (y2 - y1) / (x2 - x1) 
            y_b = y1 - m * x1 
            
            # 기울기로 좌우 구분
            if m > 0.1 : 
                r_m.append(m); r_b.append(y_b)
            elif m < -0.1: 
                l_m.append(m); l_b.append(y_b)

    # 초기화
    rx, lx = 0.0, 0.0
    r_cross, l_cross = 0, 0
    
    # --- 오른쪽 라인 계산 ---
    if len(r_m) > 0 and len(r_m) <75:
        avg_m = np.mean(r_m)
        avg_y_b = np.mean(r_b)
        lart_r_m =r_m.copy()
        lart_r_b = r_b.copy()
        if avg_m != 0: 
            r_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = r_cross - 320
            rx = float(er/1000)
        
            # 시각화
            x_start = int((0 - avg_y_b) / avg_m)
            x_end = int((y_end_roi - avg_y_b) / avg_m)
            
            center_x_r = int((x_start + x_end) / 2)
            center_y_r = int((0 + y_end_roi) / 2)
            cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (255, 0, 0), 5)
            cv2.circle(line_draw, (center_x_r, center_y_r), 10, (255, 0, 0), -1)
    elif len(r_m) > 0:
        avg_m = np.mean(lart_r_m)
        avg_y_b = np.mean(lart_r_b)
        
        if avg_m != 0: 
            r_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = r_cross - 320
            rx = float(er/1000)
        
            # 시각화
            x_start = int((0 - avg_y_b) / avg_m)
            x_end = int((y_end_roi - avg_y_b) / avg_m)
            
            center_x_r = int((x_start + x_end) / 2)
            center_y_r = int((0 + y_end_roi) / 2)
            cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (255, 0, 0), 5)
            cv2.circle(line_draw, (center_x_r, center_y_r), 10, (255, 0, 0), -1)
    # --- 왼쪽 라인 계산 ---
    if len(l_m) > 0 and len(l_m) < 75:  
        avg_m = np.mean(l_m)
        avg_y_b = np.mean(l_b)
        lart_l_m =l_m.copy()
        lart_l_b = l_b.copy()
        if avg_m != 0:
            l_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = l_cross - 320
            lx = float(er/1000)
            
            # 시각화
            x_start = int((0 - avg_y_b) / avg_m)
            x_end = int((y_end_roi - avg_y_b) / avg_m)

            center_x_l = int((x_start + x_end) / 2)
            center_y_l = int((0 + y_end_roi) / 2)

            cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (0, 255, 0), 5)
            cv2.circle(line_draw, (center_x_l, center_y_l), 10, (255, 0, 0), -1)
    elif len(l_m) > 0  :
        avg_m = np.mean(lart_l_m)
        avg_y_b = np.mean(lart_l_b)
        
        if avg_m != 0: 
            l_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = l_cross - 320
            lx = float(er/1000)
        
            # 시각화
            x_start = int((0 - avg_y_b) / avg_m)
            x_end = int((y_end_roi - avg_y_b) / avg_m)
            
            center_x_l = int((x_start + x_end) / 2)
            center_y_l = int((0 + y_end_roi) / 2)
            cv2.line(line_draw, (x_start, 0), (x_end, y_end_roi), (255, 0, 0), 5)
            cv2.circle(line_draw, (center_x_r, center_y_r), 10, (255, 0, 0), -1)

    # ------------------------------------------------
    # 5. 최종 조향 결정 로직 (곡선 대응)
    # ------------------------------------------------
    final_steering = 0.0
    
    lines_detected_both = (r_cross != 0 and l_cross != 0)
    lines_are_crossing = (lines_detected_both and l_cross >= r_cross)
    
    if lines_are_crossing:
        # 곡선: 바깥쪽 차선 추종
        mid_point = (l_cross + r_cross) / 2
        
        if mid_point < 320:
            final_steering = rx # 왼쪽 커브 -> 오른쪽 라인 따라감
        else:
            final_steering = lx # 오른쪽 커브 -> 왼쪽 라인 따라감

    elif lines_detected_both:
        final_steering = (rx + lx) / 2 # 직선 -> 중앙

    elif r_cross != 0:
        final_steering = rx

    elif l_cross != 0:
        final_steering = lx

    else:
        final_steering = last_steering

    # ------------------------------------------------
    # 6. 모터 제어 실행
    # ------------------------------------------------
    
    if abs(final_steering) > MAX_STEERING:
        steering = math.copysign(MAX_STEERING, final_steering)
    else:
        steering = final_steering

    if -1.0 <= steering <= 1.0:
        servo.value = steering
        motor.forward(0.7)
        last_steering = steering
    else:
        motor.stop()

    # ------------------------------------------------
    # 7. 화면 출력
    # ------------------------------------------------
    cv2.imshow("Lane View", line_draw)
    
    # 'q' 키를 누르면 while 루프 종료
    if cv2.waitKey(1) == ord('q'):
        break

# [수정됨] 루프 종료 후 단순 리소스 해제
cap.release() 
cv2.destroyAllWindows()
