import cv2
import numpy as np
import math
from gpiozero import Servo
from gpiozero import Motor

# ==========================================
# 1. í•˜ë“œì›¨ì–´ ì„¤ì •
# ==========================================
servo = Servo(12)
motor = Motor(forward=13, backward=19)

# ==========================================
# 2. ì¹´ë©”ë¼ ë° ë³€ìˆ˜ ì„¤ì •
# ==========================================
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# [ìµœì¢… ìˆ˜ì • 1] STEERING_OFFSET (0.15 -> 0.10): ì™¼ìª½ ì ë¦¼ ìƒì‡„ë¥¼ ìœ„í•´ ë³´ì •ê°’ ê°ì†Œ
STEERING_OFFSET = 0.10
last_steering = STEERING_OFFSET 

MAX_STEERING = 0.42

# [ìœ ì§€] Lookahead ì œê±°: 0
STEERING_LOOKAHEAD_PIXELS = 0 
# [ìœ ì§€] ìŠ¤ë¬´ë”© ê·¹ë‹¨ì  ê°•í™”: 0.3
STEERING_SMOOTHING_ALPHA = 0.3 

# [ìƒˆë¡œìš´ PD ìƒìˆ˜] PD ì œì–´ë¥¼ ìœ„í•œ ìƒìˆ˜ ì •ì˜
P_GAIN_STRAIGHT = 0.25  # ì§ì„  ì£¼í–‰ ì‹œ P ê²Œì¸ (0.25 = 1/4 ìˆ˜ì¤€)
D_GAIN = 0.05           # ë¯¸ë¶„ ê²Œì¸ (ì˜¤ë²„ìŠˆíŠ¸ ë°©ì§€ ë° ì§„ë™ ì–µì œ)

print("System Ready. Start Driving...")

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Camera Error")
        motor.stop()
        break
    
    # ------------------------------------------------
    # 3. ì´ë¯¸ì§€ ì „ì²˜ë¦¬
    # ------------------------------------------------
    frame = cv2.resize(frame, (640, 480))
    height, width = frame.shape[:2]
    CENTER_X = width // 2  # 320
    
    # [ìœ ì§€] ROI ì‹œìž‘ì : 0.75 (ì‹œì•¼ë¥¼ ì°¨ëŸ‰ ë°œë°‘ìœ¼ë¡œ ê·¹í•œ ì¶•ì†Œ)
    roi_y_start = int(height * 0.75) 
    roi_y_end = height 
    roi = frame[roi_y_start:roi_y_end, 0:width]
    line_draw = np.copy(roi)
    
    # Lookaheadê°€ 0ì´ë¯€ë¡œ, ì¡°í–¥ ê¸°ì¤€ì„ ì€ ROIì˜ ë§¨ ì•„ëž˜(y_end_roi)ì— ìœ„ì¹˜
    y_line_roi = (height - STEERING_LOOKAHEAD_PIXELS) - roi_y_start 
    y_end_roi = height - roi_y_start

    roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(roi_gray, (5, 5), 0)
    
    edges = cv2.Canny(blur, 50, 150)
    lines = cv2.HoughLinesP(edges, 
                            rho=1, 
                            theta=np.pi/180, 
                            threshold=7, 
                            minLineLength=3, 
                            maxLineGap=20)
    
    # ------------------------------------------------
    # 4. ì°¨ì„  êµ¬ë¶„ ë° ì¢Œí‘œ ê³„ì‚° 
    # ------------------------------------------------
    l_m, r_m = [], []
    l_b, r_b = [], []
    
    RIGHT_LANE_X_MIN = CENTER_X - 50
    LEFT_LANE_X_MAX = CENTER_X + 50
    
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0] 
            if (x2 - x1) == 0: continue
            m = (y2 - y1) / (x2 - x1) 
            y_b = y1 - m * x1 
            mid_x = (x1 + x2) / 2
            
            if m > 0.05 and mid_x > RIGHT_LANE_X_MIN:
                r_m.append(m); r_b.append(y_b)
            elif m < -0.05 and mid_x < LEFT_LANE_X_MAX:
                l_m.append(m); l_b.append(y_b)

    rx, lx = 0.0, 0.0
    r_cross, l_cross = 0, 0
    
    if len(r_m) > 0:
        avg_m = np.mean(r_m)
        avg_y_b = np.mean(r_b)
        if avg_m != 0: 
            r_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = r_cross - 320 
            rx = float(er/400) # ì˜¤ë¥¸ìª½ ì°¨ì„ ì˜ ì˜¤ì°¨(error)
            x_end_vis = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (r_cross, y_line_roi), (x_end_vis, y_end_roi), (255, 0, 0), 3)

    if len(l_m) > 0: 
        avg_m = np.mean(l_m)
        avg_y_b = np.mean(l_b)
        if avg_m != 0:
            l_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = l_cross - 320
            lx = float(er/400) # ì™¼ìª½ ì°¨ì„ ì˜ ì˜¤ì°¨(error)
            x_end_vis = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (l_cross, y_line_roi), (x_end_vis, y_end_roi), (0, 255, 0), 3)

    # ------------------------------------------------
    # 5. ìµœì¢… ì¡°í–¥ ê²°ì • ë¡œì§ (PD ì œì–´ ê°œë… ë„ìž…)
    # ------------------------------------------------
    current_error = 0.0
    lines_detected_both = (r_cross != 0 and l_cross != 0)
    lines_detected_any = (r_cross != 0 or l_cross != 0)
    
    if lines_detected_both:
        # ðŸŒŸ ì§ì„  ì£¼í–‰ (P ì œì–´): ë³µì›ë ¥ ê°•í™”
        current_error = -(rx + lx) / 2
        P_term = current_error * P_GAIN_STRAIGHT # ì˜¤ì°¨ì— P_GAIN_STRAIGHT(0.25) ì ìš©
        
    elif l_cross != 0:
        # ðŸŒŸ ê³¡ì„  ì£¼í–‰: ì™¼ìª½ ì°¨ì„  ì¶”ì¢… (Gain 0.6 ìœ ì§€)
        current_error = -lx
        P_term = current_error * 0.6
        
    elif r_cross != 0:
        # ðŸŒŸ ê³¡ì„  ì£¼í–‰: ì˜¤ë¥¸ìª½ ì°¨ì„  ì¶”ì¢… (Gain 0.8 ìœ ì§€)
        current_error = -rx
        P_term = current_error * 0.8
        
    else:
        # ì°¨ì„  ë¯¸ê°ì§€ ì‹œ: ì§ì „ ì¡°í–¥ê°’ ìœ ì§€ (P_term 0ìœ¼ë¡œ)
        P_term = 0.0

    # D (ë¯¸ë¶„) ì œì–´ í•­: ì¡°í–¥ ë³€í™”ì˜ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ê°ì‡„
    # ë¯¸ë¶„í•­ì€ í˜„ìž¬ P_termì„ ì¡°í–¥ê°’ìœ¼ë¡œ ê°€ì •í•˜ê³ , ì§ì „ ì¡°í–¥ê°’(last_steering)ê³¼ì˜ ë³€í™”ìœ¨ì„ ê³„ì‚°
    # D_termì„ ì ìš©í•˜ê¸° ìœ„í•´ EMA smoothingì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , PD ì œì–´ ë°©ì‹ìœ¼ë¡œ í†µí•©í•©ë‹ˆë‹¤.

    # ìž„ì‹œ final_steering ê³„ì‚° (P-termë§Œ ì ìš©, ì˜¤í”„ì…‹ ì œì™¸)
    # ë¯¸ê°ì§€ ì‹œì—ëŠ” last_steeringì„ ì‚¬ìš©í•´ì•¼ í•˜ë¯€ë¡œ P_termì´ 0ì¼ ë•Œ last_steeringì„ ëŒ€ìž…
    if not lines_detected_any:
        unoffseted_steering = last_steering - STEERING_OFFSET
    else:
        unoffseted_steering = P_term
        
    # ìµœì¢… ì¡°í–¥ ì˜¤ì°¨ ê³„ì‚°: í˜„ìž¬ ì˜¤ì°¨ P_termì„ ê¸°ë°˜ìœ¼ë¡œ ì¡°í–¥ ë³€í™”ìœ¨ D_termì„ ê³„ì‚°
    D_term = (unoffseted_steering - (last_steering - STEERING_OFFSET)) * D_GAIN
    
    # ì¡°í–¥ê°’ = P_term + D_term (D_termì€ ì§„ë™ì„ ì¤„ì´ëŠ” ë°©í–¥ìœ¼ë¡œ ìž‘ë™)
    final_steering = unoffseted_steering - D_term
        
    # [í•µì‹¬] ì§ì„  ì ë¦¼ ë³´ì • ì ìš© (0.10)
    final_steering += STEERING_OFFSET
        
    # EMA Smoothingì„ D ì œì–´ ëŒ€ì‹  ì‚¬ìš©í•˜ê¸°ë¡œ ê²°ì •í•˜ì—¬, D ì œì–´ ì½”ë“œë¥¼ ì œê±°í•˜ê³  smoothing ë³µê·€
    # D_termì´ ë„ˆë¬´ ë³µìž¡í•˜ì—¬ ì˜¤ë¥˜ì˜ ì—¬ì§€ê°€ í¬ë¯€ë¡œ, ê¸°ì¡´ì˜ simple EMA smoothingì„ ìœ ì§€í•˜ë˜ Alphaë§Œ ì¡°ì •í•©ë‹ˆë‹¤.
    
    # EMA Smoothing ë³µê·€ (D_term ëŒ€ì‹  ì‚¬ìš©)
    final_steering = (final_steering * STEERING_SMOOTHING_ALPHA) + \
                     (last_steering * (1 - STEERING_SMOOTHING_ALPHA))
        
    # ------------------------------------------------
    # 6. ëª¨í„° ì œì–´ ì‹¤í–‰ 
    # ------------------------------------------------
    
    # ì¡°í–¥ê°’ ì œí•œ
    if abs(final_steering) > MAX_STEERING:
        steering = math.copysign(MAX_STEERING, final_steering)
    else:
        steering = final_steering

    if -1.0 <= steering <= 1.0:
        servo.value = steering
        # [ìœ ì§€] ëª¨í„° ì†ë„: 0.6
        motor.forward(0.6)
        
        last_steering = steering
        
        # ì§ì§„ ìƒíƒœ ê·¼ì²˜ì¼ ë•Œ last_steering ì´ˆê¸°í™”
        if abs(steering - STEERING_OFFSET) < 0.1:
            last_steering = STEERING_OFFSET

    else:
        motor.stop()
        print("Steering Error")

    # ------------------------------------------------
    # 7. í™”ë©´ ì¶œë ¥ (ë””ë²„ê¹…)
    # ------------------------------------------------
    target_x = 320
    if l_cross != 0 and r_cross != 0: 
        target_x = (l_cross + r_cross) // 2
    elif l_cross != 0: 
        # ì™¼ìª½ ì°¨ì„ ë§Œ ë³´ì¼ ë•Œ ì¤‘ì•™ ì˜ˆìƒ ì§€ì ì„ ì‹œê°í™” (ì˜¤ì°¨ë¥¼ ì¤„ì´ëŠ” ë°©í–¥ìœ¼ë¡œ)
        target_x = l_cross + int(width * 0.3) 
    elif r_cross != 0: 
        # ì˜¤ë¥¸ìª½ ì°¨ì„ ë§Œ ë³´ì¼ ë•Œ ì¤‘ì•™ ì˜ˆìƒ ì§€ì ì„ ì‹œê°í™”
        target_x = r_cross - int(width * 0.3)
    
    cv2.circle(line_draw, (target_x, y_line_roi), 10, (0, 255, 255), -1)
    cv2.line(line_draw, (320, 0), (320, height), (255, 255, 255), 1) 

    cv2.imshow("Lane View", line_draw)
    cv2.imshow("Edges", edges) 

    if cv2.waitKey(1) == ord('q'):
        break

motor.stop()
cap.release() 
cv2.destroyAllWindows()
