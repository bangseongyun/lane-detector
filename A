import cv2
import numpy as np
import math
from gpiozero import Servo
from gpiozero import Motor

# ==========================================
# 1. 하드웨어 설정
# ==========================================
servo = Servo(12)
motor = Motor(forward=13, backward=19)

# ==========================================
# 2. 카메라 및 변수 설정
# ==========================================
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

last_steering = 0.0  # 차선을 놓쳤을 때 직전 값을 기억하기 위한 변수
MAX_STEERING = 0.45  # 최대 조향각 (과도한 꺾임 방지)

# 직선 쏠림 보정 (0.25 유지): 직선 주행이 괜찮다면 이 값은 건드리지 않습니다.
STEERING_OFFSET = 0.25

print("System Ready. Start Driving...")
motor.forward(0.7)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Camera Error")
        motor.stop()
        break
    
    # ------------------------------------------------
    # 3. 이미지 전처리
    # ------------------------------------------------
    frame = cv2.resize(frame, (640, 480))
    height, width = frame.shape[:2]
    CENTER_X = width // 2  # 320
    
    # ROI 설정 (하단 절반)
    roi_y_start = int(height * 0.45) # 216
    roi_y_end = height 
    roi = frame[roi_y_start:roi_y_end, 0:width]
    line_draw = np.copy(roi)
    
    # 조향 기준선 (ROI 상단에서 100픽셀 아래) -> 너무 멀리 보지 않도록 설정 (곡선 인식 유리)
    y_line_roi = (height - 100) - roi_y_start 
    y_end_roi = height - roi_y_start

    # 전처리: Gray -> Blur -> Canny
    roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(roi_gray, (5, 5), 0)
    edges = cv2.Canny(blur, 50, 150)

    # [수정 1] HoughLinesP 파라미터 조정 (곡선 인식률 극대화)
    # minLineLength를 5로 줄여서 짧게 끊어지는 곡선 조각도 잡아냄
    # maxLineGap을 20으로 늘려서 끊긴 선을 더 잘 연결함
    lines = cv2.HoughLinesP(edges, 
                            rho=1, 
                            theta=np.pi/180, 
                            threshold=8, 
                            minLineLength=5,  # [중요] 10 -> 5로 감소 (곡선 조각 인식)
                            maxLineGap=20)    # [중요] 15 -> 20으로 증가 (연결성 강화)
    
    # ------------------------------------------------
    # 4. 차선 구분 및 좌표 계산 
    # ------------------------------------------------
    l_m, r_m = [], []
    l_b, r_b = [], []
    
    # [수정 2] 탐색 범위 확장 (급커브 시 차선이 중앙을 넘어올 수 있음)
    # 중앙(320)을 기준으로 약간의 여유만 두고 겹치게 설정
    RIGHT_LANE_X_MIN = CENTER_X - 50  # 270 (중앙보다 왼쪽까지 침범 허용)
    LEFT_LANE_X_MAX = CENTER_X + 50   # 370 (중앙보다 오른쪽까지 침범 허용)
    
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0] 
            if (x2 - x1) == 0: continue
            m = (y2 - y1) / (x2 - x1) 
            y_b = y1 - m * x1 
            
            mid_x = (x1 + x2) / 2
            
            # [수정 3] 기울기 임계값 완화 (0.1 -> 0.05)
            # 곡선에서 차선이 거의 수평으로 보일 때 무시하지 않도록 함
            
            # 오른쪽 차선: 기울기 양수 (> 0.05), 위치는 오른쪽 영역
            if m > 0.05 and mid_x > RIGHT_LANE_X_MIN:
                r_m.append(m); r_b.append(y_b)
            # 왼쪽 차선: 기울기 음수 (< -0.05), 위치는 왼쪽 영역
            elif m < -0.05 and mid_x < LEFT_LANE_X_MAX:
                l_m.append(m); l_b.append(y_b)

    # 초기화
    rx, lx = 0.0, 0.0
    r_cross, l_cross = 0, 0
    
    # ==================================================
    # 4-1. 오른쪽 라인 처리
    # ==================================================
    if len(r_m) > 0:
        avg_m = np.mean(r_m)
        avg_y_b = np.mean(r_b)
        if avg_m != 0: 
            r_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = r_cross - 320 
            rx = float(er/400) 
            # 시각화 (빨간색)
            x_end_vis = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (r_cross, y_line_roi), (x_end_vis, y_end_roi), (255, 0, 0), 3)

    # ==================================================
    # 4-2. 왼쪽 라인 처리
    # ==================================================
    if len(l_m) > 0: 
        avg_m = np.mean(l_m)
        avg_y_b = np.mean(l_b)
        if avg_m != 0:
            l_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = l_cross - 320
            lx = float(er/400) 
            # 시각화 (초록색)
            x_end_vis = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (l_cross, y_line_roi), (x_end_vis, y_end_roi), (0, 255, 0), 3)

    # ------------------------------------------------
    # 5. 최종 조향 결정 로직
    # ------------------------------------------------
    final_steering = 0.0
    lines_detected_both = (r_cross != 0 and l_cross != 0)
    lines_detected_any = (r_cross != 0 or l_cross != 0)
    
    if lines_detected_both:
        # 양쪽 감지 시: 안정적인 중앙값
        final_steering = -(rx + lx) / 2
        
    elif l_cross != 0:
        # 왼쪽만 감지 (우회전 커브 가능성 높음)
        # 곡선 인식 시 조금 더 강하게 반응하도록 Gain 조정 (1.0 -> 1.2)
        # 하지만 부드럽게 유지하기 위해 너무 높이지 않음
        final_steering = -lx * 1.2 
        
    elif r_cross != 0:
        # 오른쪽만 감지 (좌회전 커브 가능성 높음)
        # 오른쪽 차선만 보일 때 중앙 복귀 힘 강화 (1.3 -> 1.4)
        final_steering = -rx * 1.4
        
    else:
        # [핵심] 차선 미감지 시: 
        # 곡선에서 차선을 놓치면 0.0으로 가는 게 아니라 '직전 조향값'을 유지해야 
        # 커브를 돌던 관성대로 계속 돌 수 있음.
        final_steering = last_steering
        
    # 직선 쏠림 보정 적용
    final_steering += STEERING_OFFSET
        
    # ------------------------------------------------
    # 6. 모터 제어 실행 
    # ------------------------------------------------
    
    # 조향값 제한
    if abs(final_steering) > MAX_STEERING:
        steering = math.copysign(MAX_STEERING, final_steering)
    else:
        steering = final_steering

    if -1.0 <= steering <= 1.0:
        servo.value = steering
        motor.forward(0.7)
        
        # 차선 감지 시에만 last_steering 업데이트
        if lines_detected_any:
            last_steering = steering
        
        # [추가] 만약 현재 steering이 거의 직진(오프셋 근처)이라면,
        # last_steering을 오프셋으로 확실히 초기화 (직선구간 종료 후 커브 진입 대비)
        if abs(steering - STEERING_OFFSET) < 0.1:
            last_steering = STEERING_OFFSET

    else:
        motor.stop()
        print("Steering Error")

    # ------------------------------------------------
    # 7. 화면 출력 (디버깅)
    # ------------------------------------------------
    # 목표 지점 표시
    target_x = 320
    if l_cross != 0 and r_cross != 0: target_x = (l_cross + r_cross) // 2
    elif l_cross != 0: target_x = l_cross + 175
    elif r_cross != 0: target_x = r_cross - 175
    
    cv2.circle(line_draw, (target_x, y_line_roi), 10, (0, 255, 255), -1)
    cv2.line(line_draw, (320, 0), (320, height), (255, 255, 255), 1) 

    cv2.imshow("Lane View", line_draw)
    # 엣지 화면을 꼭 확인하세요. 곡선에서 선이 끊겨 보이는지 확인 필요.
    cv2.imshow("Edges", edges) 

    if cv2.waitKey(1) == ord('q'):
        break

motor.stop()
cap.release() 
cv2.destroyAllWindows()
